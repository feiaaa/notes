## React前端技术与工程实践

@(读书笔记)

### 基本信息
![封面](https://img3.doubanio.com/view/subject/l/public/s29419062.jpg)
- [豆瓣读书简介](https://book.douban.com/subject/27013710/)


### 笔记部分
#####  1.3 React特点
虚拟dom，组件化，单向数据流
#####  2.3.5 虚拟DOM的特殊属性
reactElement 的四个属性：type props key refs

##### 3.1 组件主要成员
组件的成员state props render

##### 3.2 生命周期
> 生命周期三个阶段 实例化 活动 销毁
> [具体周期和用途](https://www.jianshu.com/p/9203997f053d)

##### 3.3 组件事件响应
> 事件和dom的相比，多了事件代理和自动绑定
> 事件 使用全局事件监听
> 自动绑定 this 指向实例
> 合成事件是浏览器原生实现跨浏览器的封装。与浏览器原生事件有同样的接口。

##### 3.6 关于state的几个设计原则
> 只有对用户输入服务器请求时间变化等需要做出响应并暂存中间状态的，才需要state。
> 组件应该尽可能的无状态化，减少冗余。[关于有状态和无状态的解释](https://blog.csdn.net/xiangzhihong8/article/details/80762125)

##### 3.6.3 哪些数据不应该放入state中?
计算所得数据，基于props的重复数据。react 组件

##### 5.3.1 可控组件
> 组件状态完全基于react的state，属性的情绪允许下，可以选择控组件的方式。
> 具有两大优点，
- 符合单向数据流特性及从state流向render的输出结果，
- 数据存储的state中，方便访问和处理。

##### 5.3.2 不可控组件，
不将value绑到state的组建，是一个不可控组件。这样的数据和state数据并不对应，所以不可控。


#### 6 复合组件

##### 6.1 组件嵌套
>父组卷要包含子组件有两种方式，
- 一种是在父的render函数中直接渲染子组件，这种子主件的类型的属性是一致的，也是通用的方法。
- 组件类型和属性是设计师位置或者动态加入的，就需要使用this.props.children属性。会自动将所有组件的实例填入this.props.children属性中。伏组件可以根据这个属性与子组件进行各种操作。


##### 6.2.1 动态参数传递
使用context，做出组件树上的数据越级传递。

##### 6.3 组件间的通信	
> 父传子用props
> 非父子关系，或者是子传数据给父。
###### 6.3.1 事件回调机制
- 子传父，父组件在props加callback，子调用
- 没有父子关系的，在didmount里订阅事件，在willunmount退订

###### 6.3.2 公开组件功能
- 是逐渐对外提供公开方法，公开方法被调用后返回相应数据。父组件通过ref属性获得实例引用。

###### 6.3.3 mixins	
> 组件之间共享逻辑,具有共同的功能或共同行为。
> 例如定时更新页面，同样要用生命周期销毁

##### 6.3.4 动态子级
动态子级，列表的item使用key防止反复渲染


##### 6.4高阶组件，
> 替代了mixins
> 对于原来组件有修改功能，又不想破坏原组件


#### 9 React实用技巧
##### 9.1 绑定React未提供的事件(绑定真实dom事件)
在didmount添加，willunmoint卸载，常用与和jq混用

##### 9.2 通过AJAX加载初始数据
> 请求url应该通过props传入，在didmount加载，加载后存在state 用setstate渲染，通过this.ismounted()检测组件状态是否已经mounted
> 解决异步不显示的办法 请求后面加 .bind（this）
> 推荐用fetch

##### 9.3 使用ref属性	
##### 9.3.1 ref字符串属性
通过this.refs访问真正的组件
##### 9.3.2 ref回调函数属性
refs可以是值也可以是回调函数

- 不要在渲染函数或者被调过程中访问refs
- 无组件状态了引用不会被加载

##### 9.4 使用classNames.js
classnames.js管理变动的class名

